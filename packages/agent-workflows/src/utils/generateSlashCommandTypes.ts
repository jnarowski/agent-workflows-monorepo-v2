import type { CommandDefinition } from '../types/workflow.js';
import { writeFile, mkdir } from 'fs/promises';
import path from 'path';
import { generateResponseTypeCode, commandNameToTypeName } from './generateCommandResponseTypes.js';

/**
 * Generate TypeScript code from command definitions
 *
 * @param commands - Array of parsed command definitions
 * @returns Generated TypeScript code as a string
 */
export function generateSlashCommandTypesCode(commands: CommandDefinition[]): string {
  if (commands.length === 0) {
    return `// Auto-generated by agent-workflows generate-slash-types
// No commands found

export type SlashCommandName = never;
export type SlashCommandArgs = Record<string, never>;

export function buildSlashCommand(): string {
  throw new Error("No slash commands available");
}
`;
  }

  // Generate command name union type
  const commandNames = commands.map((cmd) => `"${cmd.name}"`).join(' | ');

  // Generate args interface mapping
  const argsMapping = commands
    .map((cmd) => {
      if (cmd.arguments.length === 0) {
        return `  "${cmd.name}": Record<string, never>;`;
      }

      const argTypes = cmd.arguments
        .map((arg) => {
          const optional = arg.required ? '' : '?';
          // Quote property names to handle kebab-case
          return `"${arg.name}"${optional}: string`;
        })
        .join('; ');

      return `  "${cmd.name}": { ${argTypes} };`;
    })
    .join('\n');

  // Generate buildSlashCommand implementation
  const buildFunction = `/**
 * Build a type-safe slash command string
 *
 * @param name - Command name (e.g., "/generate-prd")
 * @param args - Command arguments object
 * @returns Formatted command string with escaped quotes
 *
 * @example
 * buildSlashCommand("/generate-prd", { featureName: "auth", context: "Add OAuth" })
 * // Returns: "/generate-prd 'auth' 'Add OAuth'"
 */
export function buildSlashCommand<T extends SlashCommandName>(
  name: T,
  args: SlashCommandArgs[T]
): string {
  const parts = [name];

  // Add arguments in order (if any)
  if (args && typeof args === "object") {
    for (const value of Object.values(args)) {
      // Skip undefined values (optional arguments)
      if (value !== undefined && value !== null) {
        // Escape single quotes in the value
        const escaped = String(value).replace(/'/g, "\\\\'");
        parts.push(\`'\${escaped}'\`);
      }
    }
  }

  return parts.join(" ");
}`;

  // Generate response type interfaces
  const responseTypes = commands
    .filter((cmd) => cmd.responseSchema)
    .map((cmd) => generateResponseTypeCode(cmd.name, cmd.responseSchema!))
    .join('\n');

  // Generate SlashCommandResponses mapping
  const responsesMapping = commands
    .filter((cmd) => cmd.responseSchema)
    .map((cmd) => {
      const typeName = commandNameToTypeName(cmd.name);
      return `  "${cmd.name}": ${typeName};`;
    })
    .join('\n');

  const responsesInterface = responsesMapping
    ? `/**\n * Mapping of slash commands to their JSON response types\n */\nexport interface SlashCommandResponses {\n${responsesMapping}\n}`
    : '';

  // Combine all parts
  return `// Auto-generated by agent-workflows generate-slash-types
// Do not edit this file manually

/**
 * Union type of all available slash command names
 */
export type SlashCommandName = ${commandNames};

/**
 * Mapping of command names to their argument types
 */
export interface SlashCommandArgs {
${argsMapping}
}

${buildFunction}
${responseTypes ? '\n' + responseTypes : ''}${responsesInterface ? '\n' + responsesInterface : ''}
`;
}

/**
 * Convenience wrapper that orchestrates parse → generate → write
 *
 * @param inputDir - Directory containing .claude/commands/*.md files
 * @param outputPath - Path to write generated TypeScript file
 */
export async function generateSlashCommandTypesFromDir(inputDir: string, outputPath: string): Promise<void> {
  const { parseSlashCommands } = await import('./parseSlashCommands.js');

  // Parse commands
  const commands = await parseSlashCommands(inputDir);

  // Generate code
  const code = generateSlashCommandTypesCode(commands);

  // Ensure output directory exists
  const outputDir = path.dirname(outputPath);
  await mkdir(outputDir, { recursive: true });

  // Write to file
  await writeFile(outputPath, code, 'utf-8');
}
