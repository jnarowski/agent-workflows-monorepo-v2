// Auto-generated by agent-workflows generate-slash-types
// Do not edit this file manually

/**
 * Union type of all available slash command names
 */
export type SlashCommandName = "/check" | "/commit" | "/fix" | "/generate-feature" | "/generate-prd" | "/generate-research" | "/generate-slash-command" | "/implement-spec" | "/prime" | "/pull-request" | "/review-spec-implementation" | "/review" | "/test" | "/tools";

/**
 * Mapping of command names to their argument types
 */
export interface SlashCommandArgs {
  "/check": { "format": string };
  "/commit": Record<string, never>;
  "/fix": Record<string, never>;
  "/generate-feature": { "featureName": string; "context": string; "format": string };
  "/generate-prd": { "featurename": string; "context": string; "format": string };
  "/generate-research": { "featureName": string; "researchTopic": string; "format": string };
  "/generate-slash-command": { "command-name": string; "description": string };
  "/implement-spec": { "specNameOrPath": string; "format": string };
  "/prime": Record<string, never>;
  "/pull-request": { "title": string; "format": string };
  "/review-spec-implementation": { "specFilePath": string; "format": string };
  "/review": Record<string, never>;
  "/test": Record<string, never>;
  "/tools": Record<string, never>;
}

/**
 * Build a type-safe slash command string
 *
 * @param name - Command name (e.g., "/generate-prd")
 * @param args - Command arguments object
 * @returns Formatted command string with escaped quotes
 *
 * @example
 * buildSlashCommand("/generate-prd", { featureName: "auth", context: "Add OAuth" })
 * // Returns: "/generate-prd 'auth' 'Add OAuth'"
 */
export function buildSlashCommand<T extends SlashCommandName>(
  name: T,
  args: SlashCommandArgs[T]
): string {
  const parts = [name];

  // Add arguments in order (if any)
  if (args && typeof args === "object") {
    for (const value of Object.values(args)) {
      // Skip undefined values (optional arguments)
      if (value !== undefined && value !== null) {
        // Escape single quotes in the value
        const escaped = String(value).replace(/'/g, "\\'");
        parts.push(`'${escaped}'`);
      }
    }
  }

  return parts.join(" ");
}

/**
 * Response type for /check command
 */
export interface CheckResult {
  /** Always true if check command completed (even if validation failed) */
  success: boolean;
  /** The command that was executed from README */
  validation_command: string;
  issues: {
    errors: number;
    warnings: number;
    info: number;
  };
}

/**
 * Response type for /generate-feature command
 */
export interface GenerateFeatureResult {
  /** Always true if spec generation completed */
  success: boolean;
  /** Path to the generated spec file */
  spec_path: string;
  /** Normalized feature name (lowercase, hyphenated) */
  feature_name: string;
  /** Array of phase names from Implementation Plan */
  phases: string[];
  /** Number of task groups in Step by Step Tasks section */
  task_groups: number;
  /** Total number of tasks across all groups */
  total_tasks: number;
  /** Array of existing files that will be modified */
  files_to_modify: string[];
  /** Array of new files that will be created */
  files_to_create: string[];
  /** True if Acceptance Criteria section has items */
  has_acceptance_criteria: boolean;
  /** True if Validation section has commands */
  has_validation: boolean;
}

/**
 * Response type for /generate-prd command
 */
export interface GeneratePrdResult {
  /** Always true if PRD generation completed */
  success: boolean;
  /** Path to the generated PRD file */
  prd_path: string;
  /** Normalized feature name (lowercase, hyphenated) */
  feature_name: string;
  /** The main objective from the PRD */
  primary_objective: string;
}

/**
 * Response type for /generate-research command
 */
export interface GenerateResearchResult {
  /** Always true if research generation completed */
  success: boolean;
  /** Path to the generated research file */
  research_path: string;
  /** Normalized feature name (lowercase, hyphenated) */
  feature_name: string;
  /** The research question or topic */
  research_topic: string;
  /** Number of parallel agents deployed */
  agents_deployed: number;
  /** Number of agents that successfully completed */
  agents_completed: number;
  /** Number of findings where multiple agents agreed */
  consensus_findings_count: number;
  /** Total number of unique insights across all agents */
  unique_insights_count: number;
  /** Number of conflicting findings or open questions */
  conflicts_count: number;
  /** Number of recommendations provided */
  recommendations_count: number;
  /** Total number of sources cited across all agents */
  total_sources: number;
  /** Counts by confidence level (high/medium/low) */
  confidence_breakdown: {
    high: number;
    medium: number;
    low: number;
  };
}

/**
 * Response type for /implement-spec command
 */
export interface ImplementSpecResult {
  /** Always true if implementation completed */
  success: boolean;
  /** Path to the spec file that was implemented */
  spec_path: string;
  /** Normalized feature name (lowercase, hyphenated) */
  feature_name: string;
  /** Total number of tasks in the spec */
  total_tasks: number;
  /** Number of tasks completed (should equal total_tasks) */
  completed_tasks: number;
  /** Number of existing files modified */
  files_modified: number;
  /** Number of new files created */
  files_created: number;
  /** Total lines added + removed */
  total_lines_changed: number;
  /** Number of lines added */
  lines_added: number;
  /** Number of lines removed */
  lines_removed: number;
  /** True if all validation steps passed */
  validation_passed: boolean;
  /** Output from git diff --stat */
  git_diff_stat: string;
}

/**
 * Response type for /pull-request command
 */
export interface PullRequestResult {
  /** Always true if PR creation completed */
  success: boolean;
  /** Full URL to the created pull request */
  pr_url: string;
  /** Pull request number */
  pr_number: number;
  /** Title of the pull request */
  pr_title: string;
  /** Source branch name */
  branch: string;
  /** Target/base branch name (usually main/master) */
  base_branch: string;
  /** SHA of the commit pushed */
  commit_sha: string;
  /** Full commit message including body */
  commit_message: string;
  /** Number of files changed */
  files_changed: number;
  /** Number of lines added */
  lines_added: number;
  /** Number of lines removed */
  lines_removed: number;
  /** Array of labels applied to the PR */
  labels: string[];
  /** Boolean indicating if PR is in draft mode */
  draft: boolean;
}

/**
 * Response type for /review-spec-implementation command
 */
export interface ReviewSpecImplementationResult {
  /** True if review passed, false if it failed */
  success: boolean;
  /** Current iteration number (1-based, auto-detected) */
  review_iteration: number;
  /** Always 3 */
  max_iterations: number;
  /** True if review_iteration > 3 */
  max_iterations_reached: boolean;
  /** Path to spec file reviewed */
  spec_path: string;
  /** Current git branch */
  branch: string;
  /** Number of commits since branching */
  commits_reviewed: number;
  /** Total issues in this review iteration */
  issues_found: number;
  /** Count of issues from previous review that were fixed (0 if first review) */
  previous_issues_resolved: number;
  /** Counts by priority level */
  priority_breakdown: {
    high: number;
    medium: number;
  };
  /** Counts by issue category */
  categories: {
    missing_implementations: number;
    incomplete_implementations: number;
    code_quality: number;
  };
}

/**
 * Mapping of slash commands to their JSON response types
 */
export interface SlashCommandResponses {
  "/check": CheckResult;
  "/generate-feature": GenerateFeatureResult;
  "/generate-prd": GeneratePrdResult;
  "/generate-research": GenerateResearchResult;
  "/implement-spec": ImplementSpecResult;
  "/pull-request": PullRequestResult;
  "/review-spec-implementation": ReviewSpecImplementationResult;
}
